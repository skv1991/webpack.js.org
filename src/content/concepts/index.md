---
title: Концепции
sort: 1
contributors:
  - TheLarkInn
  - jhnns
  - grgur
  - johnstew
  - jimrfenner
  - TheDutchCoder
  - adambraimbridge
  - EugeneHlushko
  - jeremenichelli
  - arjunsajeev
  - byzyk
---

По сути, **webpack** это _сборщик статических ресурсов модулей_ для современных JavaScript приложений. Когда webpack обрабатывает ваше приложение, он строит внутреннее _дерево зависимостей_, которое отмечает каждый модуль, нужный для проекта и генерирует один или более _бандл_.

T> Узнайте больше о модулях в JavaScript и модулях webpack [здесь](/concepts/modules).

Начиная с версии 4, **webpack не требует файла конфигурации** сборки проекта, тем не менее, он [необычайно гибкий](/configuration) для лучшего соответствия вашм нуждам.

Чтобы приступить к изучению, вам нужно всего лишь понять его **ключевые концепции**:

- Вход
- Вывод
- Загрузчики
- Плагины

Этот документ предназначен дать вам **обобщенный** обзор данных концепций, предоставляя при этом ссылки на детальные примеры использования концепций в конкретных ситуациях.


## Вход

**Точка входа** указывает webpack на модуль, который ему нужно использовать для начала построения внутреннего *дерева зависимостей*, webpack определит, от каких остальных библиотек и модулей этот входной модуль зависит (прямо и косвенно).

По-умолчанию, он называется `./src/index.js`, но вы можете указать другой (или множество точек входа) изменяя свойство **entry** в [конфигурации webpack](/configuration). Например:

__webpack.config.js__

``` js
module.exports = {
  entry: './path/to/my/entry/file.js'
};
```

T> Изучить подробнее можно в разделе [входные точки](/concepts/entry-points).


## Вывод

Свойство **output** сообщает webpack куда складывать создаваемые *бандлы*, и как их именовать, по-умолчанию это `./dist/main.js` для вывода основного файла и в директорию `./dist` будут попадать любые другие сгенерированные файлы.

Вы можете настроить эту часть процесса, указав поле `output` в вашей конфигурации:

__webpack.config.js__

```javascript
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};
```

В примере выше, мы используем свойства `output.filename` и `output.path`, чтобы сообщить webpack имя нашего бандла и куда мы хотим его положить. В случае, если вас удивил модуль path, импортируемый в верхней части, это [модуль ядра Node.js](https://nodejs.org/api/modules.html), который используется для управления путями файлов.

T> Свойство `output` имеет [намного больше настраиваемых возможностей](/configuration/output) и если вы хотите узнать больше о его концепциях, то можете [прочитать больше в разделе Вывод](/concepts/output).


## Загрузчики

Из коробки, webpack понимает лишь JavaScript файлы. **Загрузчики** (англ. loaders) позволяют webpack обрабатывать другие типы файлов и конвертировать их в соответствующие [модули](/concepts/modules), которые будут использованы вашим приложением и добавлены в дерево зависимостей.

W> Обратите внимание, что возможность делать `import` любого типа файлов, например `.css` файлов, это возможность webpack и она может не поддерживаться другими сборщиками или менеджерами задач. Мы чувствуем, что такое расширение языка оправдано, потому что позволяет разработчикам строить более точное дерево зависимостей.

Грубо говоря, у **loaders** есть два свойства в конфигурации webpack:

1. Свойство `test` указывает какой тип файла или файлов должен быть трансформирован.
2. Свойство `use` указывает, какой загрузчик должен использоваться для выполнения трансформации.

__webpack.config.js__

```javascript
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  }
};
```

Конфигурация выше определяет свойство `rules` (правила) для отдельного модуля с двумя обязательными свойствами: `test` и `use`. Это сообщает компилятору webpack следующее:

> "Эй, компилятор webpack, когда ты встретишь путь, соответствующий файлу с расширением '.txt' в конструкции `require()`/`import`, **use** (используй) загрузчик `raw-loader` для его трансформации перед добавлением в бандл."

W> Важно запомнить, что при объявлении правил в конфигурации webpack, нужно описывать их в свойстве `module.rules`, а не просто в `rules`. Для вашего блага, webpack сообщит, если это было сделано некорректно.

Вы можете посмотреть дальнейшую персонализацию при подключении загрузчиков в [разделе загрузчики](/concepts/loaders).


## Плагины

В то время, как загрузчики используются для трансформации конкретных типов модулей, плагины могут задействоваться для выполнения более широкого спектра задач, вроде оптимизации бандлов, управления ресурсами и внедрения переменных окружения.

T> Ознакомьтесь с [интерфейсом плагинов](/api/plugins) и их использованием для расширения возможностей webpack.

Для использования плагина, вам нужно подключить плагин используя функцию `require()` и добавить его в массив `plugins`. Большинство плагинов можно настроить через опции. Поскольку вы можете использовать плагин множество раз в конфигурации для разных нужды, нужно создать экземпляр плагина, вызвав его с оператором `new`.

**webpack.config.js**

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin'); //установлено с помощью npm
const webpack = require('webpack'); //для доступа к встроенным плагинам

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
```

В примере выше, плагин `html-webpack-plugin` генерирует html-файл для вашего приложения и автоматически внедряет в него все ваши сгенерированные бандлы.

T> Есть множество плагинов, которые webpack предоставляет прямо из коробки! Ознакомьтесь со [списком плагинов](/plugins).

Использовать плагины в конфигурации webpack достаточно просто - однако, есть множество случаев использования, которые заслуживают более детального изучения, [подробнее ознакомиться можно здесь](/concepts/plugins).


## Режим

Устанавливая параметр `mode` на `development` (разработка), `production` (релиз) или `none` (отсутствует), вы можете включить встроенную в webpack оптимизацию, которая будет соответствовать каждому окружению. По-умолчанию применяется значение `production`.

```javascript
module.exports = {
  mode: 'production'
};
```

Узнайте больше о [конфигурации режимов здесь](/concepts/mode) и какая оптимизация выполняется для каждого из значений.


## Совместимость с браузерами

webpack поддерживает все браузеры, которые [совместимы с ES5](https://kangax.github.io/compat-table/es5/) (IE8 и ниже не поддерживаются). webpack требует `Promise` для функции `import()` и `require.ensure()`. Если вы хотите осуществлять поддержку более старых браузеров, то нужно [загрузить полифилл](/guides/shimming/) до использования выражения.
